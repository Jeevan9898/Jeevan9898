<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeevan Yadav | Space Narrative</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Syncopate:wght@700&family=Outfit:wght@100;400;900&display=swap');
        
        body, html { margin: 0; padding: 0; background: #050505; color: white; font-family: 'Outfit', sans-serif; overflow-x: hidden; cursor: none; }
        #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100vh; z-index: 1; pointer-events: none; }

        /* UI ELEMENTS */
        #cursor-hud {
            position: fixed; top: 0; left: 0; pointer-events: none; z-index: 1000;
            display: flex; align-items: center; justify-content: center;
            transform: translate(-50%, -50%); mix-blend-mode: difference;
        }
        .crosshair {
            width: 40px; height: 40px; border: 1px solid rgba(0, 242, 255, 0.5);
            border-radius: 50%; position: relative; transition: all 0.2s ease-out;
            display: flex; justify-content: center; align-items: center;
        }
        .crosshair::before, .crosshair::after { content: ''; position: absolute; background: #00f2ff; transition: background 0.2s; }
        .crosshair::before { width: 100%; height: 1px; }
        .crosshair::after { width: 1px; height: 100%; }
        .cursor-data {
            position: absolute; top: 10px; left: 40px; 
            font-family: 'Syncopate'; font-size: 0.6rem; color: #00f2ff; white-space: nowrap;
        }
        .locked .crosshair { border-color: #ff4500; transform: scale(0.8) rotate(45deg); border-width: 2px; }
        .locked .crosshair::before, .locked .crosshair::after { background: #ff4500; }
        .locked .cursor-data { color: #ff4500; }

        /* SOUND TOGGLE */
        .sound-btn {
            position: fixed; bottom: 30px; left: 30px; z-index: 9999;
            color: #555; font-family: 'Syncopate'; font-size: 0.7rem; cursor: pointer;
            pointer-events: auto; display: flex; align-items: center; gap: 10px;
            transition: color 0.3s; border: 1px solid #333; padding: 10px 20px; background: rgba(0,0,0,0.8);
        }
        .sound-btn:hover, .sound-btn.active { color: #00f2ff; border-color: #00f2ff; }
        .sound-icon { width: 15px; height: 15px; display: flex; justify-content: center; align-items: center; }

        /* MODAL */
        #skill-modal {
            position: fixed; inset: 0; z-index: 200; display: flex; justify-content: center; align-items: center;
            opacity: 0; pointer-events: none; transition: opacity 0.3s ease;
        }
        #skill-modal.active { opacity: 1; pointer-events: auto; }
        .modal-content {
            background: rgba(10, 10, 10, 0.95); border: 1px solid #00f2ff; padding: 40px;
            width: 70%; max-width: 500px; position: relative; 
            box-shadow: 0 0 50px rgba(0, 242, 255, 0.1); backdrop-filter: blur(5px);
        }
        #modal-title { font-family: 'Syncopate'; color: #fff; font-size: 1.8rem; margin: 0 0 10px 0; text-transform: uppercase; }
        #modal-subtitle { font-family: 'Syncopate'; color: #00f2ff; font-size: 0.8rem; margin-bottom: 20px; display: block; border-bottom: 1px solid #333; padding-bottom: 15px; }
        #modal-desc { font-family: 'Outfit'; color: #eee; font-size: 1rem; line-height: 1.5; }

        /* LOADER */
        #loader { 
            position: fixed; inset: 0; background: #000; z-index: 2000; 
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            transition: opacity 1s ease; pointer-events: auto; cursor: pointer;
        }
        .loader-text { font-family: 'Syncopate'; color: #00f2ff; margin-top: 20px; letter-spacing: 5px; font-size: 0.8rem; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }

        /* SECTIONS */
        .content-layer { position: relative; z-index: 5; }
        section { height: 100vh; display: flex; flex-direction: column; justify-content: center; padding-left: 10%; pointer-events: none; }
        h1 { font-size: clamp(3rem, 10vw, 8rem); font-weight: 900; margin: 0; line-height: 0.9; text-transform: uppercase; }
        p { font-size: 1.5rem; max-width: 600px; color: #ccc; margin-top: 20px; font-weight: 200; }
        .tag { color: #00f2ff; font-family: 'Syncopate'; font-size: 0.8rem; letter-spacing: 3px; border-bottom: 1px solid #00f2ff; display: inline-block; margin-bottom: 10px; }

        /* HUD LABELS */
        .hud-label { position: absolute; color: #00f2ff; font-family: 'Syncopate'; font-size: 0.6rem; border-left: 2px solid #00f2ff; padding-left: 10px; opacity: 0; pointer-events: none; transition: opacity 0.3s; white-space: nowrap; }
    </style>
</head>
<body>

    <div id="cursor-hud">
        <div class="crosshair"></div>
        <div class="cursor-data">X: 000 | Y: 000</div>
    </div>

    <div class="sound-btn" id="sound-toggle">
        <div class="sound-icon">ðŸ”Š</div>
        <span id="sound-text">SOUND: OFF</span>
    </div>

    <div id="skill-modal" onclick="closeBrief()">
        <div class="modal-content">
            <h1 id="modal-title">DATA</h1>
            <span id="modal-subtitle">...</span>
            <p id="modal-desc">...</p>
        </div>
    </div>

    <div id="loader" onclick="forceStart()">
        <div class="loader-text">INITIALIZING...</div>
    </div>

    <div id="labels">
        <div id="lbl-head" class="hud-label">LOGIC_CORE [ACTIVE]</div>
        <div id="lbl-obj" class="hud-label" style="border-left:none; border-right:2px solid #00f2ff; padding-right:10px; text-align:right; opacity:0;">
            <span id="obj-name">UNKNOWN</span><br><span style="font-size:0.5rem; color:white;">ANALYZING</span>
        </div>
    </div>

    <div id="canvas-container"></div>

    <div class="content-layer">
        <section>
            <div>
                <span class="tag">SECTOR_01</span>
                <div style="height: 250px;"></div> 
                <p>Blockchain Developer & Web3 Architect.</p>
            </div>
        </section>
        <section>
            <div>
                <span class="tag">SECTOR_02</span>
                <h1>KEY<br>PROJECTS</h1>
                <p>Hover over the Data Cubes.</p>
            </div>
        </section>
        <section>
            <div>
                <span class="tag">SECTOR_03</span>
                <h1>SKILLS &<br>STACK</h1>
                <p>Scanning Asteroid Field.</p>
            </div>
        </section>
        <section>
            <div>
                <span class="tag">SECTOR_04</span>
                <h1>ACADEMIC<br>LOGS</h1>
                <p>Education & Certifications.</p>
            </div>
        </section>
        <section>
            <div>
                <span class="tag">SECTOR_05</span>
                <h1>CONTACT<br>UPLINK</h1>
                <p>Click UFOs to establish connection.</p>
            </div>
        </section>
        <div style="height: 50vh;"></div>
    </div>

    <script type="module">
        // --- DATA ---
        const projectsData = [
            { name: "PROJECT ALPHA", desc: "A revolutionary DeFi protocol built on Ethereum.", pos: {x: -5, y: 1, z: -15} },
            { name: "PROJECT BETA", desc: "Next-gen NFT marketplace with zero gas fees.", pos: {x: 5, y: -1, z: -15} },
            { name: "PROJECT GAMMA", desc: "AI-driven DAO governance voting system.", pos: {x: 0, y: 3, z: -15} }
        ];

        const skillsData = [
            { name: "SOLIDITY", pos: { x: -8, y: 3, z: -25 }, desc: "Expertise in writing secure smart contracts.", level: "MASTERY: 90%" },
            { name: "THREE.JS", pos: { x: 8, y: 4, z: -25 }, desc: "Creating immersive 3D web experiences.", level: "MASTERY: 85%" },
            { name: "C++ / DSA", pos: { x: -6, y: -4, z: -25 }, desc: "Algorithms & Logic.", level: "MASTERY: 95%" },
            { name: "REACT", pos: { x: 6, y: -3, z: -25 }, desc: "Frontend Architecture.", level: "MASTERY: 92%" },
            { name: "SYS ARCH", pos: { x: 0, y: 0, z: -25 }, desc: "System Design.", level: "MASTERY: 88%" }
        ];

        const eduData = [
            { name: "BACHELOR DEGREE", desc: "2022-2026 | Computer Science Engineering", pos: {x: -4, y: 1, z: -35} },
            { name: "MASTER CERT", desc: "2024 | Advanced Blockchain Security", pos: {x: 4, y: -1, z: -35} }
        ];

        const contactData = [
            { id: "linkedin", label: "in", url: "https://linkedin.com", pos: { x: -6, y: 2, z: -50 } },
            { id: "gmail", label: "M", url: "mailto:jeevanyadav9898@gmail.com", pos: { x: 0, y: 3, z: -50 } },
            { id: "github", label: "Git", url: "https://github.com", pos: { x: 6, y: 2, z: -50 } }
        ];

        // --- SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 5;
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- GROUPS ---
        const projectGroup = new THREE.Group(); scene.add(projectGroup);
        const asteroidGroup = new THREE.Group(); scene.add(asteroidGroup);
        const eduGroup = new THREE.Group(); scene.add(eduGroup);
        const ufoGroup = new THREE.Group(); scene.add(ufoGroup);
        
        // --- LIGHTS ---
        const dirLight = new THREE.DirectionalLight(0xffffff, 1); dirLight.position.set(5, 5, 5); scene.add(dirLight);
        const blueLight = new THREE.PointLight(0x00f2ff, 2, 50); blueLight.position.set(-5, 0, 5); scene.add(blueLight);
        const ambient = new THREE.AmbientLight(0x222222); scene.add(ambient);

        // --- ASSETS ---
        const manager = new THREE.LoadingManager();
        const gltfLoader = new THREE.GLTFLoader(manager);
        const fontLoader = new THREE.FontLoader(manager);

        // ROBOT
        let robot, head, mixer, eyesMat;
        gltfLoader.load('https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb', (gltf) => {
            robot = gltf.scene;
            robot.scale.set(0.8, 0.8, 0.8);
            robot.position.set(3, -2, -2);
            scene.add(robot);
            mixer = new THREE.AnimationMixer(robot);
            const idle = gltf.animations.find(a => a.name === 'Idle');
            if(idle) mixer.clipAction(idle).play();
            robot.traverse(o => { 
                if(o.isMesh && o.name.includes('Eye')) {
                    o.material = new THREE.MeshBasicMaterial({ color: 0x00f2ff });
                    eyesMat = o.material;
                }
                if(o.isBone && o.name === 'Head') head = o; 
            });
        });

        // RINGS
        const rings = [];
        const ringGeo = new THREE.TorusGeometry(8, 0.05, 16, 100);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0x00f2ff, transparent: true, opacity: 0.3 });
        const ringPositions = [-2, -15, -25, -35, -50];
        ringPositions.forEach(zPos => {
            const r = new THREE.Mesh(ringGeo, ringMat);
            r.position.z = zPos;
            scene.add(r);
            rings.push(r);
        });

        // STARS
        const starsGeo = new THREE.BufferGeometry();
        const starsCount = 40000;
        const posArray = new Float32Array(starsCount * 3);
        for(let i=0; i<starsCount*3; i++) posArray[i] = (Math.random()-0.5)*300;
        starsGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const starField = new THREE.Points(starsGeo, new THREE.PointsMaterial({size:0.05, color:0xffffff, transparent:true, opacity:0.8}));
        scene.add(starField);

        // DUST
        const dustGeo = new THREE.BufferGeometry();
        const dustPos = new Float32Array(10000);
        for(let i=0; i<10000; i++) dustPos[i] = (Math.random()-0.5)*50;
        dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPos, 3));
        const dustSystem = new THREE.Points(dustGeo, new THREE.PointsMaterial({size:0.02, color:0x00f2ff, opacity:0.4, transparent:true}));
        scene.add(dustSystem);

        // FONTS
        fontLoader.load('https://threejs.org/examples/fonts/droid/droid_sans_regular.typeface.json', (font) => {
            const whiteMat = new THREE.MeshBasicMaterial({color: 0xffffff});
            
            const createName = (str, y) => {
                let x = -6.5;
                for(let char of str) {
                    const g = new THREE.TextGeometry(char, {font:font, size:0.8, height:0.1});
                    g.computeBoundingBox();
                    const w = g.boundingBox.max.x - g.boundingBox.min.x;
                    const m = new THREE.Mesh(g, whiteMat);
                    m.position.set(x, y, -2); scene.add(m); x += w + 0.1;
                }
            };
            createName("JEEVAN", 1.2); createName("YADAV", 0);

            // Cubes
            const boxGeo = new THREE.BoxGeometry(2, 2, 2);
            const boxMat = new THREE.MeshBasicMaterial({color: 0x00f2ff, wireframe:true});
            projectsData.forEach(p => {
                const m = new THREE.Mesh(boxGeo, boxMat);
                m.position.set(p.pos.x, p.pos.y, p.pos.z);
                m.userData = { type: 'project', data: p };
                projectGroup.add(m);
            });

            // Asteroids
            const astGeo = new THREE.IcosahedronGeometry(1, 1);
            const astMat = new THREE.MeshStandardMaterial({color:0x222222, roughness:0.8, flatShading:true});
            const astWire = new THREE.MeshBasicMaterial({color:0x00f2ff, wireframe:true, transparent:true, opacity:0.1});
            skillsData.forEach(s => {
                const grp = new THREE.Group();
                grp.add(new THREE.Mesh(astGeo, astMat));
                grp.add(new THREE.Mesh(astGeo, astWire));
                grp.children[1].scale.set(1.1,1.1,1.1);
                grp.position.set(s.pos.x, s.pos.y, s.pos.z);
                grp.userData = { type: 'skill', data: s, name: s.name };
                asteroidGroup.add(grp);
            });

            // Pyramids
            const pyrGeo = new THREE.TetrahedronGeometry(1.5);
            const pyrMat = new THREE.MeshBasicMaterial({color: 0xffd700, wireframe:true});
            eduData.forEach(e => {
                const m = new THREE.Mesh(pyrGeo, pyrMat);
                m.position.set(e.pos.x, e.pos.y, e.pos.z);
                m.userData = { type: 'edu', data: e };
                eduGroup.add(m);
            });

            // UFOs (RESTORED WITH COCKPIT)
            const rockMat = new THREE.MeshStandardMaterial({color:0x444444, roughness:1, flatShading:true});
            const ufoMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.8, roughness: 0.2 });
            const cockpitMat = new THREE.MeshBasicMaterial({ color: 0x00f2ff }); // RESTORED
            
            contactData.forEach(c => {
                const ufoUnit = new THREE.Group();
                const ufoMesh = new THREE.Group(); // Subgroup for Body + Cockpit

                const body = new THREE.Mesh(new THREE.SphereGeometry(1.5, 32, 16), ufoMat);
                body.scale.set(1, 0.3, 1);
                
                const cockpit = new THREE.Mesh(new THREE.SphereGeometry(0.7, 32, 16), cockpitMat);
                cockpit.position.y = 0.3;

                ufoMesh.add(body); 
                ufoMesh.add(cockpit); // Added Cockpit back
                ufoMesh.position.y = 4;

                const beam = new THREE.Mesh(new THREE.CylinderGeometry(0.1,2,8,32,1,true), new THREE.MeshBasicMaterial({color:0x00f2ff, transparent:true, opacity:0.1, side:THREE.DoubleSide, blending:THREE.AdditiveBlending}));
                
                const tGeo = new THREE.TextGeometry(c.label, {font:font, size:1.5, height:0.5, bevelEnabled:true, bevelThickness:0.1, bevelSize:0.05});
                const pos = tGeo.attributes.position;
                for(let i=0; i<pos.count; i++) pos.setXYZ(i, pos.getX(i)+(Math.random()-0.5)*0.2, pos.getY(i)+(Math.random()-0.5)*0.2, pos.getZ(i)+(Math.random()-0.5)*0.2);
                tGeo.computeVertexNormals(); tGeo.computeBoundingBox();
                const center = -0.5*(tGeo.boundingBox.max.x - tGeo.boundingBox.min.x);
                const txt = new THREE.Mesh(tGeo, rockMat);
                txt.position.set(center, -4, 0); txt.rotation.x = -Math.PI/6;

                ufoUnit.add(ufoMesh); ufoUnit.add(beam); ufoUnit.add(txt);
                ufoUnit.position.set(c.pos.x, c.pos.y, c.pos.z);
                ufoUnit.userData = { type: 'ufo', url: c.url };
                ufoGroup.add(ufoUnit);
            });
        });

        // --- LOGIC ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const clock = new THREE.Clock();
        
        let hoveredObj = null;
        let isHoveredRobot = false;
        let currentScroll = 0;
        let targetScroll = 0;
        let lastScrollY = 0;

        function handleInput(x, y) {
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;
            const hud = document.getElementById('cursor-hud');
            const cd = document.querySelector('.cursor-data');
            gsap.to(hud, {left: x, top: y, duration: 0.1});
            cd.innerText = `X: ${x} | Y: ${y}`;
        }
        window.addEventListener('mousemove', (e) => handleInput(e.clientX, e.clientY));
        window.addEventListener('touchmove', (e) => { if(e.touches.length>0) handleInput(e.touches[0].clientX, e.touches[0].clientY); });
        window.addEventListener('scroll', () => { targetScroll = window.scrollY; });

        // --- AUDIO ---
        let audioCtx, masterGain;
        let isSoundOn = false;
        const soundBtn = document.getElementById('sound-toggle');

        function initAudio() {
            const AC = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AC();
            masterGain = audioCtx.createGain();
            masterGain.connect(audioCtx.destination);
            masterGain.gain.value = 0;
            const osc = audioCtx.createOscillator();
            osc.frequency.value = 55;
            osc.connect(masterGain);
            osc.start();
        }

        function toggleSound() {
            if(!audioCtx) initAudio();
            if(audioCtx.state === 'suspended') audioCtx.resume();
            if(!isSoundOn) {
                masterGain.gain.setTargetAtTime(0.3, audioCtx.currentTime, 1);
                soundBtn.classList.add('active');
                document.getElementById('sound-text').innerText = "SOUND: ON";
                isSoundOn = true;
            } else {
                masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.5);
                soundBtn.classList.remove('active');
                document.getElementById('sound-text').innerText = "SOUND: OFF";
                isSoundOn = false;
            }
        }
        soundBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleSound(); });
        window.addEventListener('click', () => { if(!audioCtx) initAudio(); });

        function playNoise() {
            if(!audioCtx || !isSoundOn) return;
            const b = audioCtx.createBuffer(1, 22050, 44100);
            const d = b.getChannelData(0);
            for(let i=0;i<22050;i++) d[i] = Math.random()*2-1;
            const s = audioCtx.createBufferSource();
            s.buffer = b;
            const g = audioCtx.createGain();
            g.gain.value = 0.1;
            s.connect(g); g.connect(audioCtx.destination);
            s.start();
        }

        window.addEventListener('click', () => {
            const maxScroll = document.body.scrollHeight - window.innerHeight;
            const scrollPercent = window.scrollY / maxScroll;
            if(scrollPercent > 0.80 && hoveredObj && hoveredObj.userData.type === 'ufo') {
                window.open(hoveredObj.userData.url, '_blank');
            }
        });

        window.closeBrief = () => {
            document.getElementById('skill-modal').classList.remove('active');
            if(hoveredObj && hoveredObj.userData.type === 'skill') {
                gsap.to(hoveredObj.children[1].scale, {x:1.1, y:1.1, z:1.1});
                gsap.to(hoveredObj.children[1].material, {opacity:0.1});
                hoveredObj.children[1].material.color.set(0x00f2ff);
                gsap.to(hoveredObj.children[0].scale, {x:1, y:1, z:1});
                hoveredObj = null;
            }
        };

        window.forceStart = () => {
            const l = document.getElementById('loader');
            l.style.opacity = 0; setTimeout(()=>l.remove(), 500);
            if(!audioCtx) initAudio();
        };

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = Date.now() * 0.001;
            if(mixer) mixer.update(delta);

            if(robot && head) {
                const targetX = THREE.MathUtils.clamp(mouse.y * 0.5, -0.5, 0.5); 
                const targetY = THREE.MathUtils.clamp(mouse.x * 0.5, -0.5, 0.5);
                head.rotation.y = THREE.MathUtils.lerp(head.rotation.y, targetY, 0.1);
                head.rotation.x = THREE.MathUtils.lerp(head.rotation.x, targetX, 0.1);
            }

            currentScroll += (targetScroll - currentScroll) * 0.08;
            const maxScroll = document.body.scrollHeight - window.innerHeight;
            const scrollPercent = maxScroll > 0 ? currentScroll / maxScroll : 0;
            const travelDist = scrollPercent * 50; 

            if(starField) { starField.scale.z = 1 + Math.abs(currentScroll - lastScrollY) * 0.5; starField.rotation.z += 0.0002; }
            lastScrollY = currentScroll;

            camera.position.z = 5 - travelDist;

            const dp = dustSystem.geometry.attributes.position.array;
            for(let i=0; i<dp.length; i+=3) dp[i+1] += Math.sin(time + dp[i])*0.01;
            dustSystem.geometry.attributes.position.needsUpdate = true;

            checkInteractions(scrollPercent);

            if(projectGroup) {
                projectGroup.children.forEach((mesh, i) => {
                    mesh.position.y = (projectsData[i].pos.y) + Math.sin(time * 1.5 + i) * 0.3;
                    mesh.rotation.x += 0.002; mesh.rotation.y += 0.003;
                });
            }
            if(eduGroup) {
                eduGroup.children.forEach((mesh, i) => {
                    mesh.position.y = (eduData[i].pos.y) + Math.cos(time * 1.5 + i) * 0.3;
                    mesh.rotation.x -= 0.002; mesh.rotation.z += 0.002;
                });
            }

            if(asteroidGroup) asteroidGroup.children.forEach(a => { if(a !== hoveredObj) { a.rotation.x += 0.002; a.rotation.y += 0.003; } });
            if(ufoGroup) ufoGroup.children.forEach((u, i) => { u.children[0].position.y = 4 + Math.sin(time + i)*0.5; u.children[0].rotation.y += 0.01; });
            rings.forEach((r, i) => r.rotation.z += 0.005 * (i+1));

            if(hoveredObj && hoveredObj.userData.name) updateLabel(hoveredObj, 'lbl-obj', 60, -60);
            if(robot && robot.visible && isHoveredRobot && head) updateLabel(head, 'lbl-head', 60, -50);

            renderer.render(scene, camera);
        }

        function checkInteractions(p) {
            raycaster.setFromCamera(mouse, camera);
            let locked = false;

            if(robot) {
                if(p < 0.15) {
                    robot.visible = true;
                    robot.position.z = -2 - (p * 50);
                    const hits = raycaster.intersectObject(robot, true);
                    if(hits.length > 0) {
                        locked = true;
                        if(!isHoveredRobot) { isHoveredRobot=true; if(eyesMat) eyesMat.color.set(0xff0000); document.getElementById('lbl-head').style.opacity=1; }
                    } else if(isHoveredRobot) { isHoveredRobot=false; if(eyesMat) eyesMat.color.set(0x00f2ff); document.getElementById('lbl-head').style.opacity=0; }
                } else { robot.visible = false; }
            }

            if(p > 0.15 && p < 0.35) {
                const hits = raycaster.intersectObjects(projectGroup.children);
                if(hits.length > 0) {
                    locked = true;
                    if(hoveredObj !== hits[0].object) {
                        hoveredObj = hits[0].object;
                        showBrief(hoveredObj.userData.data.name, "PROJECT", hoveredObj.userData.data.desc);
                        showLabel(hoveredObj.userData.data.name, "DEPLOYED");
                    }
                } else if(hoveredObj && hoveredObj.userData.type === 'project') {
                    hoveredObj = null; hideBrief(); hideLabel();
                }
            }

            if(p > 0.35 && p < 0.65) {
                const hits = raycaster.intersectObjects(asteroidGroup.children, true);
                if(hits.length > 0) {
                    locked = true;
                    let target = hits[0].object.parent;
                    if(hoveredObj !== target) {
                        if(hoveredObj && hoveredObj.userData.type === 'skill') window.closeBrief(); 
                        hoveredObj = target;
                        gsap.to(target.children[1].scale, {x:2.5,y:2.5,z:2.5});
                        gsap.to(target.children[1].material, {opacity:0.8});
                        target.children[1].material.color.set(0xff4500);
                        gsap.to(target.children[0].scale, {x:0.5,y:0.5,z:0.5});
                        playNoise();
                        showBrief(target.userData.data.name, target.userData.data.level, target.userData.data.desc);
                        showLabel(target.userData.data.name, "ANALYZED");
                    }
                } else if(hoveredObj && hoveredObj.userData.type === 'skill') {
                    window.closeBrief(); hideLabel();
                }
            }
            if((p < 0.35 || p > 0.65) && hoveredObj && hoveredObj.userData.type === 'skill') {
                window.closeBrief(); hideLabel();
            }

            if(p > 0.65 && p < 0.85) {
                const hits = raycaster.intersectObjects(eduGroup.children);
                if(hits.length > 0) {
                    locked = true;
                    if(hoveredObj !== hits[0].object) {
                        hoveredObj = hits[0].object;
                        showBrief(hoveredObj.userData.data.name, "EDUCATION", hoveredObj.userData.data.desc);
                        showLabel(hoveredObj.userData.data.name, "VERIFIED");
                    }
                } else if(hoveredObj && hoveredObj.userData.type === 'edu') {
                    hoveredObj = null; hideBrief(); hideLabel();
                }
            }

            if(p > 0.85) {
                const hits = raycaster.intersectObjects(ufoGroup.children, true);
                if(hits.length > 0) {
                    locked = true;
                    let target = hits[0].object.parent;
                    if(hoveredObj !== target) {
                        if(hoveredObj && hoveredObj.userData.type === 'ufo') resetUFO(hoveredObj);
                        hoveredObj = target;
                        gsap.to(target.children[1].material, {opacity:0.6}); // Beam
                        gsap.to(target.children[2].scale, {x:1.2, y:1.2, z:1.2}); // Rock
                        target.children[2].material.color.set(0xff4500);
                        showLabel("LINK UPLINK", "CLICK TO OPEN");
                    }
                } else if(hoveredObj && hoveredObj.userData.type === 'ufo') {
                    resetUFO(hoveredObj); hoveredObj = null; hideLabel();
                }
            }

            const hud = document.getElementById('cursor-hud');
            if(locked) hud.classList.add('locked'); else hud.classList.remove('locked');
        }

        function resetUFO(grp) {
            gsap.to(grp.children[1].material, {opacity:0.1});
            gsap.to(grp.children[2].scale, {x:1, y:1, z:1});
            grp.children[2].material.color.set(0x444444);
        }

        function showBrief(t, s, d) {
            document.getElementById('modal-title').innerText = t;
            document.getElementById('modal-subtitle').innerText = s;
            document.getElementById('modal-desc').innerText = d;
            document.getElementById('skill-modal').classList.add('active');
        }
        function hideBrief() { document.getElementById('skill-modal').classList.remove('active'); }

        function showLabel(name, sub) {
            document.getElementById('lbl-obj').style.opacity = 1;
            document.getElementById('obj-name').innerText = name;
        }
        function hideLabel() { document.getElementById('lbl-obj').style.opacity = 0; }

        function updateLabel(mesh, id, ox, oy) {
            const v = new THREE.Vector3();
            mesh.getWorldPosition(v);
            v.project(camera);
            const x = (v.x * .5 + .5) * window.innerWidth + ox;
            const y = (-(v.y * .5) + .5) * window.innerHeight + oy;
            const el = document.getElementById(id);
            if(el) { el.style.left = `${x}px`; el.style.top = `${y}px`; }
        }

        setTimeout(forceStart, 3000);

        animate();
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
