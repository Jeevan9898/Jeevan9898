<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeevan Yadav | Space Narrative</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Syncopate:wght@700&family=Outfit:wght@100;400;900&display=swap');
        
        body, html { margin: 0; padding: 0; background: #050505; color: white; font-family: 'Outfit', sans-serif; overflow-x: hidden; cursor: none; }
        #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100vh; z-index: 1; pointer-events: none; }

        /* --- CURSOR HUD --- */
        #cursor-hud {
            position: fixed; top: 0; left: 0; pointer-events: none; z-index: 1000;
            display: flex; align-items: center; justify-content: center;
            transform: translate(-50%, -50%); mix-blend-mode: difference;
        }
        .crosshair {
            width: 40px; height: 40px; border: 1px solid rgba(0, 242, 255, 0.5);
            border-radius: 50%; position: relative; transition: all 0.2s ease-out;
            display: flex; justify-content: center; align-items: center;
        }
        .crosshair::before, .crosshair::after { content: ''; position: absolute; background: #00f2ff; transition: background 0.2s; }
        .crosshair::before { width: 100%; height: 1px; }
        .crosshair::after { width: 1px; height: 100%; }
        .cursor-data {
            position: absolute; top: 10px; left: 40px; 
            font-family: 'Syncopate'; font-size: 0.6rem; color: #00f2ff; white-space: nowrap;
        }
        .locked .crosshair { border-color: #ff4500; transform: scale(0.8) rotate(45deg); border-width: 2px; }
        .locked .crosshair::before, .locked .crosshair::after { background: #ff4500; }
        .locked .cursor-data { color: #ff4500; }

        /* --- LOADER --- */
        #loader { 
            position: fixed; inset: 0; background: #000; z-index: 100; 
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            transition: opacity 1s ease; pointer-events: auto; cursor: pointer;
        }
        .meteor-core { width: 20px; height: 20px; background: #00f2ff; border-radius: 50%; box-shadow: 0 0 20px #00f2ff, 0 0 40px #00f2ff; animation: pulse 0.8s infinite alternate; z-index: 2; position: relative; }
        .meteor-ring-container { position: relative; width: 100px; height: 100px; display: flex; justify-content: center; align-items: center; }
        .meteor-ring { position: absolute; width: 60px; height: 60px; border: 2px solid rgba(0, 242, 255, 0.3); border-top: 2px solid #00f2ff; border-radius: 50%; animation: spin 1s linear infinite; }
        .meteor-ring-2 { position: absolute; width: 80px; height: 80px; border: 2px solid rgba(0, 242, 255, 0.1); border-bottom: 2px solid #00f2ff; border-radius: 50%; animation: spin-rev 1.5s linear infinite; }
        .loader-text { font-family: 'Syncopate'; color: #00f2ff; margin-top: 30px; letter-spacing: 5px; font-size: 0.8rem; animation: blink 1s infinite; }
        .click-hint { font-family: 'Outfit'; color: #666; font-size: 0.7rem; margin-top: 15px; text-transform: uppercase; animation: fade 2s infinite; }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes spin-rev { 0% { transform: rotate(0deg); } 100% { transform: rotate(-360deg); } }
        @keyframes pulse { 0% { transform: scale(0.8); opacity: 0.8; } 100% { transform: scale(1.2); opacity: 1; } }
        @keyframes blink { 50% { opacity: 0.5; } }
        @keyframes fade { 0%, 100% { opacity: 0.3; } 50% { opacity: 1; } }

        /* CONTENT */
        .content-layer { position: relative; z-index: 5; }
        section { height: 100vh; display: flex; flex-direction: column; justify-content: center; padding-left: 10%; pointer-events: none; }
        h1.hidden-name { opacity: 0; position: absolute; pointer-events: none; } 
        h1 { font-size: clamp(3rem, 10vw, 8rem); font-weight: 900; margin: 0; line-height: 0.9; text-transform: uppercase; }
        p { font-size: 1.5rem; max-width: 600px; color: #ccc; margin-top: 20px; font-weight: 200; }
        .tag { color: #00f2ff; font-family: 'Syncopate'; font-size: 0.8rem; letter-spacing: 3px; border-bottom: 1px solid #00f2ff; display: inline-block; margin-bottom: 10px; }

        /* HUD LABELS */
        .hud-label { position: absolute; color: #00f2ff; font-family: 'Syncopate'; font-size: 0.6rem; border-left: 2px solid #00f2ff; padding-left: 10px; opacity: 0; pointer-events: none; transition: opacity 0.3s; }

        /* SOUND TOGGLE */
        .sound-btn {
            position: fixed; bottom: 30px; left: 30px; z-index: 50;
            color: #555; font-family: 'Syncopate'; font-size: 0.7rem; cursor: pointer;
            pointer-events: auto; display: flex; align-items: center; gap: 10px;
            transition: color 0.3s; border: 1px solid #333; padding: 10px 20px; background: rgba(0,0,0,0.5);
        }
        .sound-btn:hover, .sound-btn.active { color: #00f2ff; border-color: #00f2ff; }
        .sound-icon { width: 15px; height: 15px; display: flex; justify-content: center; align-items: center; }

        /* SKILL MODAL */
        #skill-modal {
            position: fixed; inset: 0; z-index: 200; display: flex; justify-content: center; align-items: center;
            opacity: 0; pointer-events: none; transition: opacity 0.3s ease;
        }
        #skill-modal.active { opacity: 1; }
        .modal-content {
            background: rgba(10, 10, 10, 0.9); border: 1px solid #00f2ff; padding: 40px;
            width: 70%; max-width: 500px; position: relative; 
            box-shadow: 0 0 30px rgba(0, 242, 255, 0.2); pointer-events: none; backdrop-filter: blur(5px);
        }
        .modal-close { display: none; }
        #modal-title { font-family: 'Syncopate'; color: #fff; font-size: 1.8rem; margin: 0 0 10px 0; text-transform: uppercase; text-shadow: 0 0 10px rgba(0,242,255,0.5); }
        #modal-subtitle { font-family: 'Syncopate'; color: #00f2ff; font-size: 0.8rem; margin-bottom: 20px; display: block; border-bottom: 1px solid #333; padding-bottom: 15px; }
        #modal-desc { font-family: 'Outfit'; color: #eee; font-size: 1rem; line-height: 1.5; }

        ::-webkit-scrollbar { width: 0; }
    </style>
</head>
<body>

    <div id="cursor-hud">
        <div class="crosshair"></div>
        <div class="cursor-data">X: 000 | Y: 000</div>
    </div>

    <div class="sound-btn" id="sound-toggle">
        <div class="sound-icon">ðŸ”Š</div>
        <span id="sound-text">SOUND: OFF</span>
    </div>

    <div id="skill-modal">
        <div class="modal-content">
            <h1 id="modal-title">DATA</h1>
            <span id="modal-subtitle">DECRYPTING...</span>
            <p id="modal-desc">...</p>
        </div>
    </div>

    <div id="loader">
        <div class="meteor-ring-container">
            <div class="meteor-core"></div>
            <div class="meteor-ring"></div>
            <div class="meteor-ring-2"></div>
        </div>
        <div class="loader-text">INITIALIZING SYSTEMS...</div>
        <div class="click-hint">[ CLICK ANYWHERE TO START ]</div>
    </div>

    <div id="labels">
        <div id="lbl-head" class="hud-label">LOGIC_CORE [ACTIVE]</div>
        <div id="lbl-dims" class="hud-label" style="border-left:none; border-right:2px solid #00f2ff; padding-right:10px; text-align:right; opacity: 0; pointer-events: none;">
            SPECS<br><span id="dim-text" style="font-size:0.5rem; color:white;">CALCULATING...</span>
        </div>
        <div id="lbl-asteroid" class="hud-label" style="border-left:none; border-right:2px solid #00f2ff; padding-right:10px; text-align:right; opacity:0;">
            <span id="ast-name">UNKNOWN</span><br><span style="font-size:0.5rem; color:white;">HOVER TO SCAN</span>
        </div>
        <div id="lbl-ufo" class="hud-label" style="border-left:none; border-right:2px solid #ff4500; padding-right:10px; text-align:right; opacity:0;">
            TARGET_ACQUIRED<br><span style="font-size:0.5rem; color:white;">CLICK TO ENGAGE</span>
        </div>
    </div>

    <div id="canvas-container"></div>

    <div class="content-layer">
        <section>
            <div>
                <span class="tag">SECTOR_01</span>
                <div style="height: 250px;"></div> 
                <p>Blockchain Developer & Web3 Architect.</p>
            </div>
        </section>

        <section>
            <div>
                <span class="tag">SECTOR_02</span>
                <h1>SYSTEM<br>SPECS</h1>
                <p>Hover over data fragments to analyze.</p>
            </div>
        </section>

        <section>
            <div>
                <span class="tag">SECTOR_03</span>
                <h1>OUTPOST<br>CONTACT</h1>
                <p>Establishing secure channels via UFO uplinks.</p>
            </div>
        </section>
        <div style="height: 50vh;"></div>
    </div>

    <script type="module">
        // --- SKILL DATA ---
        const skillsData = [
            { name: "SOLIDITY", pos: { x: -8, y: 3, z: -25 }, desc: "Expertise in writing secure smart contracts, optimizing gas usage, and deploying decentralized applications.", level: "MASTERY: 90%" },
            { name: "THREE.JS", pos: { x: 8, y: 4, z: -25 }, desc: "Specialized in creating immersive 3D web experiences using WebGL and shaders.", level: "MASTERY: 85%" },
            { name: "C++ / DSA", pos: { x: -6, y: -4, z: -25 }, desc: "Strong foundation in data structures and algorithms. High-performance computing.", level: "MASTERY: 95%" },
            { name: "REACT / NEXT", pos: { x: 6, y: -3, z: -25 }, desc: "Building highly responsive and SEO-friendly frontend architectures for dApps.", level: "MASTERY: 92%" },
            { name: "SYS ARCH", pos: { x: 0, y: 0, z: -25 }, desc: "Designing scalable decentralized systems and cryptographic primitives.", level: "MASTERY: 88%" }
        ];

        const contactData = [
            { id: "linkedin", label: "in", url: "https://linkedin.com", pos: { x: -6, y: 2, z: -50 } },
            { id: "gmail", label: "M", url: "mailto:jeevanyadav9898@gmail.com", pos: { x: 0, y: 3, z: -50 } },
            { id: "github", label: "Git", url: "https://github.com", pos: { x: 6, y: 2, z: -50 } }
        ];

        function showBrief(skill) {
            document.getElementById('modal-title').innerText = skill.name;
            document.getElementById('modal-subtitle').innerText = skill.level;
            document.getElementById('modal-desc').innerText = skill.desc;
            document.getElementById('skill-modal').classList.add('active');
        }
        function hideBrief() { document.getElementById('skill-modal').classList.remove('active'); }

        const cursor = document.getElementById('cursor-hud');
        const cursorData = document.querySelector('.cursor-data');
        let mouseX = 0, mouseY = 0, cursorX = 0, cursorY = 0;
        window.addEventListener('mousemove', (e) => { mouseX = e.clientX; mouseY = e.clientY; cursorData.innerText = `X: ${mouseX} | Y: ${mouseY}`; });
        function animateCursor() {
            cursorX += (mouseX - cursorX) * 0.2; cursorY += (mouseY - cursorY) * 0.2;
            cursor.style.left = `${cursorX}px`; cursor.style.top = `${cursorY}px`;
            requestAnimationFrame(animateCursor);
        }
        animateCursor();
        function lockCursor(locked) {
            if(locked) document.getElementById('cursor-hud').classList.add('locked');
            else document.getElementById('cursor-hud').classList.remove('locked');
        }

        // --- AUDIO ENGINE ---
        let audioCtx, masterGain;
        let isSoundOn = false;
        const soundBtn = document.getElementById('sound-toggle');

        function initAudio() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();
            masterGain = audioCtx.createGain();
            masterGain.connect(audioCtx.destination);
            masterGain.gain.value = 0;

            // Ambience: Drone
            createOsc(55, 'sine', 0.6);
            createOsc(110, 'sine', 0.3);
            createOsc(112, 'sine', 0.3);
            createOsc(55, 'sawtooth', 0.05);
        }

        function createOsc(freq, type, vol) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.value = vol;
            osc.connect(gain);
            gain.connect(masterGain);
            osc.start();
        }

        function playExplosionSound() {
            if (!audioCtx || !isSoundOn) return;
            const bufferSize = audioCtx.sampleRate * 0.5; 
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 3);
            }
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const noiseGain = audioCtx.createGain();
            noiseGain.gain.value = 0.8;
            noise.connect(noiseGain);
            noiseGain.connect(audioCtx.destination);
            noise.start();
        }

        function toggleSound() {
            if(!audioCtx) initAudio();
            if(audioCtx.state === 'suspended') audioCtx.resume();

            if(!isSoundOn) {
                masterGain.gain.setTargetAtTime(0.3, audioCtx.currentTime, 1);
                soundBtn.classList.add('active');
                document.getElementById('sound-text').innerText = "SOUND: ON";
                isSoundOn = true;
            } else {
                masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.5);
                soundBtn.classList.remove('active');
                document.getElementById('sound-text').innerText = "SOUND: OFF";
                isSoundOn = false;
            }
        }

        window.addEventListener('click', () => { if(!audioCtx) { initAudio(); toggleSound(); } }, { once: true });
        soundBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleSound(); });

        setTimeout(() => {
            const l = document.getElementById('loader');
            if(l) { l.style.opacity = '0'; setTimeout(() => l.remove(), 1000); }
        }, 5000);

        // --- THREE JS ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 5;
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping; 
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const starsGeo = new THREE.BufferGeometry();
        const starsCount = 15000; 
        const posArray = new Float32Array(starsCount * 3);
        for(let i = 0; i < starsCount * 3; i++) { posArray[i] = (Math.random() - 0.5) * 300; }
        starsGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const starsMat = new THREE.PointsMaterial({ size: 0.05, color: 0xffffff, transparent: true, opacity: 0.8 });
        const starField = new THREE.Points(starsGeo, starsMat);
        scene.add(starField);

        // --- SPACE DUST (INTERACTIVE) ---
        const dustGeo = new THREE.BufferGeometry();
        const dustCount = 2000;
        const dustPos = new Float32Array(dustCount * 3);
        const dustVel = []; 
        for(let i=0; i<dustCount*3; i++) {
            dustPos[i] = (Math.random() - 0.5) * 50; 
            if(i % 3 === 0) dustVel.push({x:0, y:0, z:0, ox:dustPos[i], oy:dustPos[i+1], oz:dustPos[i+2]});
        }
        dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPos, 3));
        const dustMat = new THREE.PointsMaterial({ size: 0.02, color: 0x00f2ff, transparent: true, opacity: 0.4 });
        const dustSystem = new THREE.Points(dustGeo, dustMat);
        scene.add(dustSystem);

        const rings = [];
        const ringGeo = new THREE.TorusGeometry(6, 0.05, 32, 100); 
        const ringMat = new THREE.MeshBasicMaterial({ color: 0x00f2ff });
        for(let i=0; i<3; i++) {
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.position.set(0, 0, -(i * 25)); 
            scene.add(ring);
            rings.push(ring);
        }

        let robot, mixer, head, armL, armR;
        let originalHeadY = 0;
        let robotBox = new THREE.Box3();
        let robotSize = new THREE.Vector3();

        const manager = new THREE.LoadingManager();
        const gltfLoader = new THREE.GLTFLoader(manager);
        gltfLoader.load('https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb', (gltf) => {
            robot = gltf.scene;
            robot.scale.set(0.8, 0.8, 0.8);
            robot.position.set(3, -2, -2); 
            scene.add(robot);
            
            robotBox.setFromObject(robot);
            robotBox.getSize(robotSize);

            mixer = new THREE.AnimationMixer(robot);
            const idle = gltf.animations.find(a => a.name === 'Idle');
            if(idle) mixer.clipAction(idle).play();
            robot.traverse(o => {
                if(o.isMesh) { o.userData.origMat = o.material; if(o.name.includes('Eye')) o.material = new THREE.MeshBasicMaterial({ color: 0x00f2ff }); }
                if(o.name === 'Head') { head = o; originalHeadY = head.position.y; }
                if(o.name === 'UpperArmL') armL = o; if(o.name === 'UpperArmR') armR = o;
            });
        }, undefined, (error) => { console.error(error); });

        const asteroidGroup = new THREE.Group();
        scene.add(asteroidGroup);
        const asteroids = [];
        const astGeo = new THREE.IcosahedronGeometry(1, 1);
        const posAttribute = astGeo.attributes.position;
        for (let i = 0; i < posAttribute.count; i++) {
            const x = posAttribute.getX(i); const y = posAttribute.getY(i); const z = posAttribute.getZ(i);
            const noise = Math.random() * 0.3;
            posAttribute.setXYZ(i, x + x*noise, y + y*noise, z + z*noise);
        }
        astGeo.computeVertexNormals();
        const astMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8, metalness: 0.5, flatShading: true });
        const wireMat = new THREE.MeshBasicMaterial({ color: 0x00f2ff, wireframe: true, transparent: true, opacity: 0.1 });

        skillsData.forEach((skill, index) => {
            const ast = new THREE.Group();
            const solid = new THREE.Mesh(astGeo, astMat.clone());
            const wire = new THREE.Mesh(astGeo, wireMat.clone()); 
            wire.scale.set(1.1, 1.1, 1.1);
            ast.add(solid); ast.add(wire);
            ast.position.set(skill.pos.x, skill.pos.y, skill.pos.z);
            ast.userData = { name: skill.name, skillData: skill, id: index, exploded: false };
            asteroidGroup.add(ast);
            asteroids.push(ast);
        });

        const ufoGroup = new THREE.Group();
        scene.add(ufoGroup);
        const ufos = [];

        const fontLoader = new THREE.FontLoader();
        fontLoader.load('https://threejs.org/examples/fonts/droid/droid_sans_regular.typeface.json', (font) => {
            const whiteMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            let xCursor = -6.5; 
            const str1 = "JEEVAN";
            for (let i = 0; i < str1.length; i++) {
                const char = str1[i];
                const textGeo = new THREE.TextGeometry(char, { font: font, size: 0.8, height: 0.1, curveSegments: 12 });
                textGeo.computeBoundingBox();
                const charWidth = textGeo.boundingBox.max.x - textGeo.boundingBox.min.x;
                const mesh = new THREE.Mesh(textGeo, whiteMat);
                mesh.position.set(xCursor, 1.2, -2); 
                scene.add(mesh);
                xCursor += (charWidth + 0.1);
            }
            xCursor = -6.5;
            const str2 = "YADAV";
            for (let i = 0; i < str2.length; i++) {
                const char = str2[i];
                const textGeo = new THREE.TextGeometry(char, { font: font, size: 0.8, height: 0.1, curveSegments: 12 });
                textGeo.computeBoundingBox();
                const charWidth = textGeo.boundingBox.max.x - textGeo.boundingBox.min.x;
                const mesh = new THREE.Mesh(textGeo, whiteMat);
                mesh.position.set(xCursor, 0, -2); 
                scene.add(mesh);
                xCursor += (charWidth + 0.1);
            }

            // --- JAGGED ROCK MATERIAL ---
            const rockTextMat = new THREE.MeshStandardMaterial({ 
                color: 0x444444, roughness: 1, metalness: 0.1, flatShading: true 
            });

            contactData.forEach(item => {
                const ufoUnit = new THREE.Group();
                const ufoBodyGeo = new THREE.SphereGeometry(1.5, 32, 16);
                ufoBodyGeo.scale(1, 0.3, 1);
                const ufoCockpitGeo = new THREE.SphereGeometry(0.7, 32, 16);
                const ufoMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.8, roughness: 0.2 });
                const cockpitMat = new THREE.MeshBasicMaterial({ color: 0x00f2ff });
                const body = new THREE.Mesh(ufoBodyGeo, ufoMat);
                const cockpit = new THREE.Mesh(ufoCockpitGeo, cockpitMat);
                cockpit.position.y = 0.3;
                const ufoMesh = new THREE.Group();
                ufoMesh.add(body); ufoMesh.add(cockpit);
                ufoMesh.position.y = 4;
                const beamGeo = new THREE.CylinderGeometry(0.1, 2, 8, 32, 1, true);
                const beamMat = new THREE.MeshBasicMaterial({ color: 0x00f2ff, transparent: true, opacity: 0.1, side: THREE.DoubleSide, blending: THREE.AdditiveBlending });
                const beam = new THREE.Mesh(beamGeo, beamMat);
                beam.position.y = 0;
                
                // --- JAGGED ROCK TEXT ---
                const rockGeo = new THREE.TextGeometry(item.label, { font: font, size: 1.5, height: 0.6, curveSegments: 10, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.05 });
                const pos = rockGeo.attributes.position;
                for(let i=0; i < pos.count; i++){
                    const amp = 0.15; 
                    pos.setXYZ(i, pos.getX(i) + (Math.random() - 0.5) * amp, pos.getY(i) + (Math.random() - 0.5) * amp, pos.getZ(i) + (Math.random() - 0.5) * amp);
                }
                rockGeo.computeVertexNormals();
                rockGeo.computeBoundingBox();
                const centerOffset = -0.5 * (rockGeo.boundingBox.max.x - rockGeo.boundingBox.min.x);
                const rockMesh = new THREE.Mesh(rockGeo, rockTextMat);
                rockMesh.position.x = centerOffset;
                rockMesh.position.y = -4; 
                rockMesh.rotation.x = -Math.PI / 6;

                for(let k=0; k<5; k++) {
                    const debGeo = new THREE.DodecahedronGeometry(0.2, 0);
                    const debMesh = new THREE.Mesh(debGeo, rockTextMat);
                    debMesh.position.set(centerOffset + (Math.random()-0.5)*3, -4.2, (Math.random()-0.5)*2);
                    ufoUnit.add(debMesh);
                }

                ufoUnit.add(ufoMesh); ufoUnit.add(beam); ufoUnit.add(rockMesh);
                ufoUnit.position.set(item.pos.x, item.pos.y, item.pos.z);
                ufoUnit.userData = { id: item.id, url: item.url, type: 'ufo' };
                ufoGroup.add(ufoUnit);
                ufos.push({ group: ufoUnit, beam: beam, rock: rockMesh, ufo: ufoMesh });
            });
        });

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 5, 5); scene.add(dirLight);
        const blueLight = new THREE.PointLight(0x00f2ff, 2, 50);
        blueLight.position.set(-5, 0, 5); scene.add(blueLight);
        const rimLight = new THREE.SpotLight(0xffffff, 2);
        rimLight.position.set(0, 10, 0); scene.add(rimLight);

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredAsteroid = null;
        let isHovered = false; 
        let hoveredUFO = null;

        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            const scrollY = window.scrollY;
            const maxScroll = document.body.scrollHeight - window.innerHeight;
            const scrollPercent = scrollY / maxScroll;

            raycaster.setFromCamera(mouse, camera);
            let locked = false;

            // ROBOT SECTOR (0-20% scroll only)
            if (scrollPercent < 0.20) {
                if (robot && robot.visible) {
                    const intersects = raycaster.intersectObject(robot, true);
                    if (intersects.length > 0) {
                        locked = true;
                        if (!isHovered) { 
                            isHovered = true; 
                            if(head) gsap.to(head.position, { y: originalHeadY + 0.5, duration: 0.4 }); 
                            document.getElementById('lbl-head').style.opacity = 1;
                            robotBox.setFromObject(robot);
                            robotBox.getSize(robotSize);
                            document.getElementById('dim-text').innerText = `H:${robotSize.y.toFixed(2)}m | W:${robotSize.x.toFixed(2)}m`;
                            document.getElementById('lbl-dims').style.opacity = 1;
                        }
                    } else if (isHovered) { 
                        isHovered = false; 
                        if(head) gsap.to(head.position, { y: originalHeadY, duration: 0.4 }); 
                        document.getElementById('lbl-head').style.opacity = 0;
                        document.getElementById('lbl-dims').style.opacity = 0;
                    }
                }
            }

            if (scrollPercent > 0.35 && scrollPercent < 0.75) {
                const astIntersects = raycaster.intersectObjects(asteroidGroup.children, true);
                if (astIntersects.length > 0) {
                    locked = true;
                    let hitObj = astIntersects[0].object;
                    while(hitObj.parent && hitObj.parent !== asteroidGroup) { hitObj = hitObj.parent; }
                    if (hoveredAsteroid !== hitObj) {
                        if (hoveredAsteroid) implodeAsteroid(hoveredAsteroid);
                        hoveredAsteroid = hitObj;
                        
                        playExplosionSound();
                        
                        explodeAsteroid(hoveredAsteroid);
                        showBrief(hitObj.userData.skillData);
                        document.getElementById('lbl-asteroid').style.opacity = 1;
                        document.getElementById('ast-name').innerText = hitObj.userData.name;
                    }
                } else {
                    if (hoveredAsteroid) { implodeAsteroid(hoveredAsteroid); hideBrief(); hoveredAsteroid = null; document.getElementById('lbl-asteroid').style.opacity = 0; }
                }
            }

            if (scrollPercent > 0.75) {
                const ufoIntersects = raycaster.intersectObjects(ufoGroup.children, true);
                if (ufoIntersects.length > 0) {
                    locked = true;
                    let hitObj = ufoIntersects[0].object;
                    while(hitObj.parent && hitObj.parent !== ufoGroup) { hitObj = hitObj.parent; }
                    
                    if (hoveredUFO !== hitObj) {
                        if(hoveredUFO) {
                            const prev = ufos.find(u => u.group === hoveredUFO);
                            if(prev) {
                                gsap.to(prev.beam.material, { opacity: 0.1 });
                                gsap.to(prev.beam.scale, { x: 1, z: 1 });
                                gsap.to(prev.rock.scale, { x: 1, y: 1, z: 1 });
                                gsap.to(prev.rock.material.color, { r: 0.26, g: 0.26, b: 0.26 }); 
                            }
                        }
                        hoveredUFO = hitObj;
                        const curr = ufos.find(u => u.group === hoveredUFO);
                        if(curr) {
                            gsap.to(curr.beam.material, { opacity: 0.6 });
                            gsap.to(curr.beam.scale, { x: 1.5, z: 1.5 });
                            gsap.to(curr.rock.scale, { x: 1.2, y: 1.2, z: 1.2 });
                            gsap.to(curr.rock.material.color, { r: 1, g: 0.27, b: 0 }); 
                        }
                        document.getElementById('lbl-ufo').style.opacity = 1;
                    }
                } else {
                    if (hoveredUFO) {
                        const prev = ufos.find(u => u.group === hoveredUFO);
                        if(prev) {
                            gsap.to(prev.beam.material, { opacity: 0.1 });
                            gsap.to(prev.beam.scale, { x: 1, z: 1 });
                            gsap.to(prev.rock.scale, { x: 1, y: 1, z: 1 });
                            gsap.to(prev.rock.material.color, { r: 0.26, g: 0.26, b: 0.26 });
                        }
                        hoveredUFO = null;
                        document.getElementById('lbl-ufo').style.opacity = 0;
                    }
                }
            }
            lockCursor(locked);
        });

        window.addEventListener('click', () => {
            if(hoveredUFO) { const url = hoveredUFO.userData.url; if(url) window.open(url, '_blank'); }
        });

        function explodeAsteroid(ast) {
            const wire = ast.children[1];
            const solid = ast.children[0];
            gsap.to(wire.scale, { x: 2.5, y: 2.5, z: 2.5, duration: 0.4 });
            gsap.to(wire.material, { opacity: 0.8, duration: 0.2 });
            wire.material.color.set(0xff4500);
            gsap.to(solid.scale, { x: 0.5, y: 0.5, z: 0.5, duration: 0.4 });
            gsap.to(ast.rotation, { x: ast.rotation.x + 1, y: ast.rotation.y + 1, duration: 0.5 });
        }

        function implodeAsteroid(ast) {
            const wire = ast.children[1];
            const solid = ast.children[0];
            gsap.to(wire.scale, { x: 1.1, y: 1.1, z: 1.1, duration: 0.4 });
            gsap.to(wire.material, { opacity: 0.1, duration: 0.4 });
            wire.material.color.set(0x00f2ff);
            gsap.to(solid.scale, { x: 1, y: 1, z: 1, duration: 0.4 });
        }

        let lastScrollY = 0;
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = Date.now() * 0.001;
            if(mixer) mixer.update(delta);

            const scrollY = window.scrollY;
            const maxScroll = document.body.scrollHeight - window.innerHeight;
            const scrollPercent = scrollY / maxScroll;
            const travelDist = scrollPercent * 50; 
            
            // WARP DRIVE LOGIC
            const speed = Math.abs(scrollY - lastScrollY);
            lastScrollY = scrollY;
            if(starField) {
                starField.scale.z = 1 + speed * 0.5; // Stretch Z
                starField.rotation.z += 0.0002;
            }

            // DUST INTERACTION
            const dustPositions = dustSystem.geometry.attributes.position.array;
            for(let i=0; i<2000; i++) {
                const ix = i*3;
                dustPositions[ix+1] += Math.sin(time + dustPositions[ix]) * 0.01;
            }
            dustSystem.geometry.attributes.position.needsUpdate = true;
            
            camera.position.z = 5 - travelDist;

            // INSTANT ROBOT REMOVAL @ 20%
            if(robot) robot.visible = (scrollPercent < 0.20);
            if(robot && robot.visible) {
                robot.position.z = -2 - travelDist; 
                robot.rotation.y = (mouse.x * 0.3);
                robot.rotation.x = (mouse.y * 0.1);
            }

            // AUTO CLOSE BRIEFS IF LEAVING SECTOR 2
            if (scrollPercent > 0.70 && hoveredAsteroid) {
                implodeAsteroid(hoveredAsteroid);
                hideBrief();
                hoveredAsteroid = null;
                document.getElementById('lbl-asteroid').style.opacity = 0;
            }

            asteroids.forEach((ast, i) => {
                if(ast !== hoveredAsteroid) {
                    ast.rotation.x += 0.002 * (i % 2 === 0 ? 1 : -1);
                    ast.rotation.y += 0.003;
                }
            });

            ufos.forEach((u, i) => {
                u.ufo.position.y = 4 + Math.sin(time + i) * 0.5; 
                u.ufo.rotation.y += 0.01;
            });

            rings.forEach((r, i) => { r.rotation.z += 0.005 * (i+1); });

            if(hoveredAsteroid) { updateLabel(hoveredAsteroid, 'lbl-asteroid', -80, -60); }
            if(robot && robot.visible && head && isHovered) { 
                updateLabel(head, 'lbl-head', 60, -50); 
                updateLabel(head, 'lbl-dims', 60, 20);
            }
            if(hoveredUFO) { updateLabel(hoveredUFO, 'lbl-ufo', 60, -80); }

            renderer.render(scene, camera);
        }

        function updateLabel(mesh, id, ox, oy) {
            const v = new THREE.Vector3();
            mesh.getWorldPosition(v);
            v.project(camera);
            const x = (v.x * .5 + .5) * window.innerWidth + ox;
            const y = (-(v.y * .5) + .5) * window.innerHeight + oy;
            const el = document.getElementById(id);
            if(el) { el.style.left = `${x}px`; el.style.top = `${y}px`; }
        }

        animate();
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>